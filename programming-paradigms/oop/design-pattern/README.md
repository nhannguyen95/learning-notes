## Design Patterns
- **Creational Patterns** involves object instantiation and all provide a way to decouple a client from the objects it needs to instantiate.
  - [Simple Factory](simple-factory.md)
  - [Factory Method](factory-method.md)
  - [Abstract Factory](abstract-factory.md)
  - [Singleton](singleton.md)
  - [Builder](builder.md)
  - [Prototype](prototype.md)
  
- **Structural Patterns** lets you compose classes or objects into larger structures.
  - [Adapter](adapter.md)
  - [Composite](composite.md)
  - [Decorator](decorator.md)
  - [Facade](facade.md)
  - [Proxy](proxy.md)
  - [Bridge](bridge.md)
  - Flyweight
  
- **Behavioral Patterns** is concerned with how classes and objects interact and distribute responsibility.
  - [Command](command.md)
  - [Iterator](iterator.md)
  - [Observer](observer.md)
  - [State](state.md)
  - [Strategy](strategy.md)
  - [Template Method](template-method.md)
  - Interpreter
  - [Mediator](mediator.md)
  - Memento
  - [Visitor](visitor.md)
  - [Chain of Responsibility](chain-of-responsibility.md)

## Thinking in Patterns
- KISS: when you design, your goal is to solve things in the simplest way possible, not "how can I apply a pattern to this problem". That said, sometimes the best way to keep your design simple and flexible is to use a pattern.
- Center your thinking on design, not on patterns. Use patterns when there is a natural need for them. If something simpler will work, then use it.
- Make sure you are adding patterns to deal with *practical changes* that is likely to happen, not *hypothetical change* that may happen.

## Notes
- Like design principles, design patterns are not rules or laws. You can alter them to fit your needs. A lot of real world examples don't fit the classic pattern designs.

## Exercise
- Chapter 12: compound method.
